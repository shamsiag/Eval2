{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport Chart from 'chart.js/auto';\nexport default {\n  name: 'DashboardPage',\n  data() {\n    return {\n      allOrders: [],\n      paidSalesData: [],\n      pendingOrdersData: [],\n      apiKey: localStorage.getItem('apiKey'),\n      apiLink: localStorage.getItem('apiLink'),\n      dateFilter: 'all',\n      statusFilter: 'all',\n      totalSales: 0,\n      totalPendingOrders: 0,\n      conversionRate: 0,\n      averageOrderValue: 0,\n      charts: {},\n      productCategories: {} // Cache pour les catégories de produits\n    };\n  },\n  computed: {\n    filteredPaidSales() {\n      if (this.dateFilter === 'all') {\n        return this.paidSalesData;\n      }\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      return this.paidSalesData.filter(sale => {\n        const dateParts = sale.date.split('/');\n        const saleDate = new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);\n        if (this.dateFilter === 'today') {\n          return saleDate >= today;\n        } else if (this.dateFilter === 'week') {\n          const lastWeek = new Date(today);\n          lastWeek.setDate(today.getDate() - 7);\n          return saleDate >= lastWeek;\n        } else if (this.dateFilter === 'month') {\n          const lastMonth = new Date(today);\n          lastMonth.setMonth(today.getMonth() - 1);\n          return saleDate >= lastMonth;\n        }\n        return true;\n      });\n    },\n    filteredPendingOrders() {\n      if (this.statusFilter === 'all') {\n        return this.pendingOrdersData;\n      }\n      return this.pendingOrdersData.filter(order => {\n        return order.rawStatus === this.statusFilter;\n      });\n    }\n  },\n  mounted() {\n    this.fetchAllOrdersData();\n  },\n  methods: {\n    formatDate(timestamp) {\n      if (!timestamp) return \"Inconnue\";\n      const date = new Date(timestamp * 1000);\n      return date.toLocaleDateString(\"fr-FR\");\n    },\n    formatCurrency(value) {\n      return new Intl.NumberFormat(\"fr-FR\", {\n        style: \"currency\",\n        currency: \"EUR\"\n      }).format(value);\n    },\n    async fetchAllOrdersData() {\n      try {\n        if (!this.apiKey || !this.apiLink) {\n          throw new Error(\"API Key ou API Link manquant\");\n        }\n\n        // Récupérer toutes les commandes\n        await this.fetchOrders();\n\n        // Calculer les KPIs\n        this.calculateKPIs();\n\n        // Générer tous les graphiques\n        this.renderAllCharts();\n      } catch (error) {\n        console.error(\"Erreur lors de la récupération des données:\", error);\n      }\n    },\n    async fetchOrders() {\n      try {\n        // Récupérer toutes les commandes\n        const url = `${this.apiLink}/orders`;\n        console.log(\"URL de récupération des commandes:\", url);\n        const response = await fetch(url, {\n          headers: {\n            \"DOLAPIKEY\": this.apiKey\n          }\n        });\n        if (!response.ok) {\n          throw new Error(`Erreur réseau: ${response.statusText}`);\n        }\n        const rawOrders = await response.json();\n        console.log(\"Commandes récupérées:\", rawOrders);\n\n        // Pour chaque commande, récupérer les détails et les factures associées\n        this.allOrders = await Promise.all(rawOrders.map(async order => {\n          // Récupérer les détails de la commande\n          const orderDetails = await this.fetchOrderDetails(order.id);\n\n          // Récupérer la facture associée\n          const invoice = await this.fetchInvoiceForOrder(order.id);\n          return {\n            ...orderDetails,\n            invoice,\n            isPaid: invoice ? invoice.paye === \"1\" || invoice.paye === 1 : false\n          };\n        }));\n\n        // Traiter les données pour l'affichage\n        await this.processOrdersData();\n      } catch (error) {\n        console.error(\"Erreur lors de la récupération des commandes:\", error);\n      }\n    },\n    async fetchOrderDetails(orderId) {\n      try {\n        const url = `${this.apiLink}/orders/${orderId}`;\n        const response = await fetch(url, {\n          headers: {\n            \"DOLAPIKEY\": this.apiKey\n          }\n        });\n        if (!response.ok) {\n          throw new Error(`Erreur réseau pour la commande ${orderId}: ${response.statusText}`);\n        }\n        return await response.json();\n      } catch (error) {\n        console.error(`Erreur lors de la récupération des détails de la commande ${orderId}:`, error);\n        return null;\n      }\n    },\n    async fetchInvoiceForOrder(orderId) {\n      try {\n        const url = `${this.apiLink}/orders/${orderId}/invoices`;\n        const response = await fetch(url, {\n          headers: {\n            DOLAPIKEY: this.apiKey\n          }\n        });\n        if (!response.ok) {\n          console.warn(`Pas de facture pour la commande ${orderId}`);\n          return null;\n        }\n        const invoices = await response.json();\n        return invoices.length > 0 ? invoices[0] : null;\n      } catch (error) {\n        console.error(\"Erreur de récupération de facture pour commande\", orderId, error);\n        return null;\n      }\n    },\n    async fetchProductCategories(productId) {\n      // Si nous avons déjà récupéré les catégories pour ce produit, utiliser le cache\n      if (this.productCategories[productId]) {\n        return this.productCategories[productId];\n      }\n      try {\n        const url = `${this.apiLink}/products/${productId}/categories`;\n        const response = await fetch(url, {\n          headers: {\n            DOLAPIKEY: this.apiKey\n          }\n        });\n        if (!response.ok) {\n          console.warn(`Pas de catégories pour le produit ${productId}`);\n          this.productCategories[productId] = \"Non catégorisé\";\n          return \"Non catégorisé\";\n        }\n        const categories = await response.json();\n        if (categories && categories.length > 0) {\n          // Prendre la première catégorie comme catégorie principale\n          const categoryName = categories[0].label || \"Catégorie inconnue\";\n          this.productCategories[productId] = categoryName;\n          return categoryName;\n        } else {\n          this.productCategories[productId] = \"Non catégorisé\";\n          return \"Non catégorisé\";\n        }\n      } catch (error) {\n        console.error(`Erreur lors de la récupération des catégories pour le produit ${productId}:`, error);\n        this.productCategories[productId] = \"Erreur de catégorie\";\n        return \"Erreur de catégorie\";\n      }\n    },\n    getStatusText(order) {\n      switch (order.status) {\n        case \"0\":\n          return \"Brouillon\";\n        case \"1\":\n          if (order.billed && (order.billed === true || order.billed === \"1\")) {\n            return \"Validé-Facturé\";\n          } else if (order.invoice) {\n            return \"Validé-Facture créée\";\n          } else {\n            return \"Validé\";\n          }\n        case \"2\":\n          return \"Facturée\";\n        case \"3\":\n          return \"Livrée\";\n        case \"4\":\n          return \"Traitée\";\n        case \"5\":\n          return \"Payée\";\n        case \"-1\":\n          return \"Annulée\";\n        default:\n          return \"Statut inconnu\";\n      }\n    },\n    getStatusClass(status) {\n      switch (status) {\n        case \"0\":\n          return \"draft\";\n        case \"1\":\n          return \"validated\";\n        case \"2\":\n          return \"invoiced\";\n        case \"3\":\n          return \"processing\";\n        case \"4\":\n          return \"processed\";\n        case \"5\":\n          return \"paid\";\n        case \"-1\":\n          return \"cancelled\";\n        default:\n          return \"unknown\";\n      }\n    },\n    async processOrdersData() {\n      this.paidSalesData = [];\n      this.pendingOrdersData = [];\n\n      // Traiter chaque commande\n      for (const order of this.allOrders) {\n        // Vérifier si la commande a des lignes\n        if (order.lines && Array.isArray(order.lines)) {\n          const orderDate = this.formatDate(order.date_creation);\n          const clientName = order.socname || \"Client inconnu\";\n          const statusText = this.getStatusText(order);\n          const statusClass = this.getStatusClass(order.status);\n          const isPaid = order.isPaid || order.status === \"5\";\n\n          // Traiter chaque ligne de la commande\n          for (const line of order.lines) {\n            const productName = line.product_label || line.label || \"Produit inconnu\";\n            const productReference = line.product_ref || \"Référence inconnue\";\n            const quantity = parseFloat(line.qty) || 0;\n            const lineTotal = (parseFloat(line.subprice) * quantity).toFixed(2);\n\n            // Récupérer la catégorie du produit si nous avons un ID de produit\n            let categoryName = \"Catégorie inconnue\";\n            if (line.fk_product) {\n              categoryName = await this.fetchProductCategories(line.fk_product);\n            }\n            const saleData = {\n              date: orderDate,\n              client: clientName,\n              product: productName,\n              reference: productReference,\n              category: categoryName,\n              quantity: quantity,\n              total: lineTotal,\n              status: statusText,\n              statusClass: statusClass,\n              orderId: order.id,\n              rawStatus: order.status\n            };\n\n            // Ajouter aux données appropriées selon le statut\n            if (isPaid) {\n              this.paidSalesData.push(saleData);\n            } else {\n              this.pendingOrdersData.push(saleData);\n            }\n          }\n        }\n      }\n      console.log(\"Données des ventes payées:\", this.paidSalesData);\n      console.log(\"Données des commandes en attente:\", this.pendingOrdersData);\n    },\n    calculateKPIs() {\n      // Calculer le total des ventes\n      this.totalSales = this.paidSalesData.reduce((total, sale) => {\n        return total + parseFloat(sale.total);\n      }, 0).toFixed(2);\n\n      // Nombre total de commandes en attente\n      const uniqueOrders = new Set(this.pendingOrdersData.map(item => item.orderId));\n      this.totalPendingOrders = uniqueOrders.size;\n\n      // Calcul du panier moyen\n      const uniquePaidOrders = new Set(this.paidSalesData.map(item => item.orderId));\n      const paidOrdersCount = uniquePaidOrders.size;\n      this.averageOrderValue = paidOrdersCount > 0 ? (this.totalSales / paidOrdersCount).toFixed(2) : 0;\n\n      // Taux de conversion (commandes payées / total des commandes)\n      const totalOrders = uniqueOrders.size + paidOrdersCount;\n      this.conversionRate = totalOrders > 0 ? (paidOrdersCount / totalOrders * 100).toFixed(1) : 0;\n    },\n    renderAllCharts() {\n      // Détruire les graphiques existants si nécessaire\n      if (this.charts.categorySalesChart) {\n        Object.values(this.charts).forEach(chart => chart.destroy());\n      }\n      this.renderCategorySalesChart();\n      this.renderSalesTrendChart();\n      this.renderOrderStatusChart();\n      this.renderTopProductsChart();\n      this.renderGeoDistributionChart();\n      this.renderCustomerLoyaltyChart();\n    },\n    renderCategorySalesChart() {\n      const aggregatedByCategory = {};\n      this.paidSalesData.forEach(sale => {\n        aggregatedByCategory[sale.category] = (aggregatedByCategory[sale.category] || 0) + parseFloat(sale.total);\n      });\n      const categoryLabels = Object.keys(aggregatedByCategory);\n      const categoryData = categoryLabels.map(label => aggregatedByCategory[label]);\n      const ctx = document.getElementById('categorySalesChart');\n      if (ctx) {\n        this.charts.categorySalesChart = new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: categoryLabels,\n            datasets: [{\n              data: categoryData,\n              backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'],\n              borderWidth: 1\n            }]\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'right',\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          }\n        });\n      }\n    },\n    renderSalesTrendChart() {\n      // Grouper les ventes par date\n      const salesByDate = {};\n      this.paidSalesData.forEach(sale => {\n        salesByDate[sale.date] = (salesByDate[sale.date] || 0) + parseFloat(sale.total);\n      });\n\n      // Trier les dates\n      const sortedDates = Object.keys(salesByDate).sort((a, b) => {\n        return new Date(a.split('/').reverse().join('-')) - new Date(b.split('/').reverse().join('-'));\n      });\n      const dateLabels = sortedDates;\n      const dateData = sortedDates.map(date => salesByDate[date]);\n      const ctx = document.getElementById('salesTrendChart');\n      if (ctx) {\n        this.charts.salesTrendChart = new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: dateLabels,\n            datasets: [{\n              label: 'Ventes (€)',\n              data: dateData,\n              fill: false,\n              borderColor: '#5AAAD8',\n              tension: 0.1\n            }]\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                display: true,\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              },\n              x: {\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          }\n        });\n      }\n    },\n    renderOrderStatusChart() {\n      // Combiner les données des commandes payées et en attente\n      const allOrders = [...this.paidSalesData, ...this.pendingOrdersData];\n\n      // Compter par statut\n      const statusCounts = {};\n      allOrders.forEach(order => {\n        statusCounts[order.status] = (statusCounts[order.status] || 0) + 1;\n      });\n      const statusLabels = Object.keys(statusCounts);\n      const statusData = statusLabels.map(label => statusCounts[label]);\n      const ctx = document.getElementById('orderStatusChart');\n      if (ctx) {\n        this.charts.orderStatusChart = new Chart(ctx, {\n          type: 'pie',\n          data: {\n            labels: statusLabels,\n            datasets: [{\n              data: statusData,\n              backgroundColor: ['#28a745', '#ffc107', '#007bff', '#dc3545', '#6c757d'],\n              borderWidth: 1\n            }]\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'right',\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          }\n        });\n      }\n    },\n    renderTopProductsChart() {\n      // Agréger les ventes par produit\n      const salesByProduct = {};\n      this.paidSalesData.forEach(sale => {\n        salesByProduct[sale.product] = (salesByProduct[sale.product] || 0) + parseFloat(sale.total);\n      });\n\n      // Trier et prendre les 5 meilleurs produits\n      const sortedProducts = Object.entries(salesByProduct).sort((a, b) => b[1] - a[1]).slice(0, 5);\n      const productLabels = sortedProducts.map(item => item[0]);\n      const productData = sortedProducts.map(item => item[1]);\n      const ctx = document.getElementById('topProductsChart');\n      if (ctx) {\n        this.charts.topProductsChart = new Chart(ctx, {\n          type: 'bar',\n          data: {\n            labels: productLabels,\n            datasets: [{\n              label: 'Ventes (€)',\n              data: productData,\n              backgroundColor: '#5AAAD8',\n              borderRadius: 6\n            }]\n          },\n          options: {\n            indexAxis: 'y',\n            responsive: true,\n            plugins: {\n              legend: {\n                display: false\n              }\n            },\n            scales: {\n              x: {\n                beginAtZero: true,\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              },\n              y: {\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          }\n        });\n      }\n    },\n    renderGeoDistributionChart() {\n      // Dans une implémentation complète, vous pourriez analyser les adresses des clients \n      // Pour l'instant, utilisons des données fictives\n      const geoData = {\n        'Paris': 45,\n        'Lyon': 20,\n        'Marseille': 15,\n        'Bordeaux': 10,\n        'Lille': 5,\n        'Autres': 5\n      };\n      const geoLabels = Object.keys(geoData);\n      const geoValues = Object.values(geoData);\n      const ctx = document.getElementById('geoDistributionChart');\n      if (ctx) {\n        this.charts.geoDistributionChart = new Chart(ctx, {\n          type: 'pie',\n          data: {\n            labels: geoLabels,\n            datasets: [{\n              data: geoValues,\n              backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'],\n              borderWidth: 1\n            }]\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'right',\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          }\n        });\n      }\n    },\n    renderCustomerLoyaltyChart() {\n      // Dans une implémentation complète, vous pourriez compter les commandes par client\n      // Pour l'instant, utilisons des données fictives\n      const loyaltyData = {\n        labels: ['1 achat', '2-3 achats', '4-5 achats', '6+ achats'],\n        datasets: [{\n          label: 'Nombre de clients',\n          data: [65, 40, 25, 15],\n          backgroundColor: '#5AAAD8',\n          borderRadius: 6\n        }]\n      };\n      const ctx = document.getElementById('customerLoyaltyChart');\n      if (ctx) {\n        this.charts.customerLoyaltyChart = new Chart(ctx, {\n          type: 'bar',\n          data: loyaltyData,\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                display: false\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              },\n              x: {\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          }\n        });\n      }\n    }\n  },\n  watch: {\n    dateFilter: function () {\n      console.log(\"Filtre de date changé:\", this.dateFilter);\n      // Les données sont automatiquement filtrées via le computed property filteredPaidSales\n    },\n    statusFilter: function () {\n      console.log(\"Filtre de statut changé:\", this.statusFilter);\n      // Les données sont automatiquement filtrées via le computed property filteredPendingOrders\n    }\n  }\n};","map":{"version":3,"names":["Chart","name","data","allOrders","paidSalesData","pendingOrdersData","apiKey","localStorage","getItem","apiLink","dateFilter","statusFilter","totalSales","totalPendingOrders","conversionRate","averageOrderValue","charts","productCategories","computed","filteredPaidSales","now","Date","today","getFullYear","getMonth","getDate","filter","sale","dateParts","date","split","saleDate","lastWeek","setDate","lastMonth","setMonth","filteredPendingOrders","order","rawStatus","mounted","fetchAllOrdersData","methods","formatDate","timestamp","toLocaleDateString","formatCurrency","value","Intl","NumberFormat","style","currency","format","Error","fetchOrders","calculateKPIs","renderAllCharts","error","console","url","log","response","fetch","headers","ok","statusText","rawOrders","json","Promise","all","map","orderDetails","fetchOrderDetails","id","invoice","fetchInvoiceForOrder","isPaid","paye","processOrdersData","orderId","DOLAPIKEY","warn","invoices","length","fetchProductCategories","productId","categories","categoryName","label","getStatusText","status","billed","getStatusClass","lines","Array","isArray","orderDate","date_creation","clientName","socname","statusClass","line","productName","product_label","productReference","product_ref","quantity","parseFloat","qty","lineTotal","subprice","toFixed","fk_product","saleData","client","product","reference","category","total","push","reduce","uniqueOrders","Set","item","size","uniquePaidOrders","paidOrdersCount","totalOrders","categorySalesChart","Object","values","forEach","chart","destroy","renderCategorySalesChart","renderSalesTrendChart","renderOrderStatusChart","renderTopProductsChart","renderGeoDistributionChart","renderCustomerLoyaltyChart","aggregatedByCategory","categoryLabels","keys","categoryData","ctx","document","getElementById","type","labels","datasets","backgroundColor","borderWidth","options","responsive","plugins","legend","position","color","salesByDate","sortedDates","sort","a","b","reverse","join","dateLabels","dateData","salesTrendChart","fill","borderColor","tension","display","scales","y","beginAtZero","ticks","x","statusCounts","statusLabels","statusData","orderStatusChart","salesByProduct","sortedProducts","entries","slice","productLabels","productData","topProductsChart","borderRadius","indexAxis","geoData","geoLabels","geoValues","geoDistributionChart","loyaltyData","customerLoyaltyChart","watch"],"sources":["/Users/macbookpro/Sham/S6/stellarz-web/stellarz-b/stellar-web/src/views/DashboardPage.vue"],"sourcesContent":["<template>\n  <div class=\"dashboard\">\n    <h2 class=\"section-title\">Tableau</h2>\n    <h2 class=\"section-title\">de</h2>\n    <h2 class=\"section-title\">bord</h2>\n    \n    <div class=\"dashboard-content\">\n      <!-- Résumé des indicateurs clés -->\n      <div class=\"kpi-container\">\n        <div class=\"kpi-card\">\n          <h3>Total des ventes</h3>\n          <p class=\"kpi-value\">{{ totalSales }}€</p>\n        </div>\n        <div class=\"kpi-card\">\n          <h3>Commandes en attente</h3>\n          <p class=\"kpi-value\">{{ totalPendingOrders }}</p>\n        </div>\n        <div class=\"kpi-card\">\n          <h3>Taux de conversion</h3>\n          <p class=\"kpi-value\">{{ conversionRate }}%</p>\n        </div>\n        <div class=\"kpi-card\">\n          <h3>Panier moyen</h3>\n          <p class=\"kpi-value\">{{ averageOrderValue }}€</p>\n        </div>\n      </div>\n\n      <!-- Graphiques d'analyse -->\n      <div class=\"charts-row\">\n        <div class=\"chart-container\">\n          <h3>Ventes par catégorie</h3>\n          <canvas id=\"categorySalesChart\"></canvas>\n        </div>\n        <div class=\"chart-container\">\n          <h3>Évolution des ventes</h3>\n          <canvas id=\"salesTrendChart\"></canvas>\n        </div>\n      </div>\n      \n      <div class=\"charts-row\">\n        <div class=\"chart-container\">\n          <h3>Statut des commandes</h3>\n          <canvas id=\"orderStatusChart\"></canvas>\n        </div>\n        <div class=\"chart-container\">\n          <h3>Top produits vendus</h3>\n          <canvas id=\"topProductsChart\"></canvas>\n        </div>\n      </div>\n\n      <!-- Tableau des commandes payées -->\n      <div class=\"data-section\">\n        <div class=\"section-header\">\n          <h2>Commandes payées</h2>\n          <div class=\"filters\">\n            <select v-model=\"dateFilter\">\n              <option value=\"all\">Toutes les périodes</option>\n              <option value=\"today\">Aujourd'hui</option>\n              <option value=\"week\">Cette semaine</option>\n              <option value=\"month\">Ce mois</option>\n            </select>\n          </div>\n        </div>\n        \n        <div class=\"sales-details\">\n          <table>\n            <thead>\n              <tr>\n                <th>Date</th>\n                <th>Client</th>\n                <th>Produit</th>\n                <th>Référence</th>\n                <th>Catégorie</th>\n                <th>Quantité</th>\n                <th>Total</th>\n                <th>Statut</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr v-for=\"(sale, index) in filteredPaidSales\" :key=\"'paid-'+index\">\n                <td>{{ sale.date }}</td>\n                <td>{{ sale.client }}</td>\n                <td>{{ sale.product }}</td>\n                <td>{{ sale.reference }}</td>\n                <td>{{ sale.category }}</td>\n                <td>{{ sale.quantity }}</td>\n                <td>{{ sale.total }}€</td>\n                <td><span class=\"status-tag paid\">{{ sale.status }}</span></td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n\n      <!-- Tableau des commandes en cours -->\n      <div class=\"data-section\">\n        <div class=\"section-header\">\n          <h2>Commandes en attente</h2>\n          <div class=\"filters\">\n            <select v-model=\"statusFilter\">\n              <option value=\"all\">Tous les statuts</option>\n              <option value=\"0\">Brouillon</option>\n              <option value=\"1\">Validée</option>\n              <option value=\"3\">En traitement</option>\n            </select>\n          </div>\n        </div>\n        \n        <div class=\"sales-details\">\n          <table>\n            <thead>\n              <tr>\n                <th>Date</th>\n                <th>Produit</th>\n                <th>Référence</th>\n                <th>Catégorie</th>\n                <th>Quantité</th>\n                <th>Total</th>\n                <th>Statut</th>\n                <th>Actions</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr v-for=\"(order, index) in filteredPendingOrders\" :key=\"'pending-'+index\">\n                <td>{{ order.date }}</td>\n                <td>{{ order.client }}</td>\n                <td>{{ order.product }}</td>\n                <td>{{ order.reference }}</td>\n                <td>{{ order.category }}</td>\n                <td>{{ order.quantity }}</td>\n                <td>{{ order.total }}€</td>\n                <td><span :class=\"'status-tag ' + order.statusClass\">{{ order.status }}</span></td>\n                <td>\n                  <button class=\"action-btn\">Détails</button>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n\n      <!-- Analyse des clients -->\n    </div>\n  </div>\n</template>\n\n<script>\nimport Chart from 'chart.js/auto';\n\nexport default {\n  name: 'DashboardPage',\n  data() {\n    return {\n      allOrders: [],\n      paidSalesData: [],\n      pendingOrdersData: [],\n      apiKey: localStorage.getItem('apiKey'),\n      apiLink: localStorage.getItem('apiLink'),\n      dateFilter: 'all',\n      statusFilter: 'all',\n      totalSales: 0,\n      totalPendingOrders: 0,\n      conversionRate: 0,\n      averageOrderValue: 0,\n      charts: {},\n      productCategories: {} // Cache pour les catégories de produits\n    };\n  },\n  computed: {\n    filteredPaidSales() {\n      if (this.dateFilter === 'all') {\n        return this.paidSalesData;\n      }\n      \n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      \n      return this.paidSalesData.filter(sale => {\n        const dateParts = sale.date.split('/');\n        const saleDate = new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);\n        \n        if (this.dateFilter === 'today') {\n          return saleDate >= today;\n        } else if (this.dateFilter === 'week') {\n          const lastWeek = new Date(today);\n          lastWeek.setDate(today.getDate() - 7);\n          return saleDate >= lastWeek;\n        } else if (this.dateFilter === 'month') {\n          const lastMonth = new Date(today);\n          lastMonth.setMonth(today.getMonth() - 1);\n          return saleDate >= lastMonth;\n        }\n        return true;\n      });\n    },\n    filteredPendingOrders() {\n      if (this.statusFilter === 'all') {\n        return this.pendingOrdersData;\n      }\n      \n      return this.pendingOrdersData.filter(order => {\n        return order.rawStatus === this.statusFilter;\n      });\n    }\n  },\n  mounted() {\n    this.fetchAllOrdersData();\n  },\n  methods: {\n    formatDate(timestamp) {\n      if (!timestamp) return \"Inconnue\";\n      const date = new Date(timestamp * 1000);\n      return date.toLocaleDateString(\"fr-FR\");\n    },\n    formatCurrency(value) {\n      return new Intl.NumberFormat(\"fr-FR\", {\n        style: \"currency\",\n        currency: \"EUR\"\n      }).format(value);\n    },\n    async fetchAllOrdersData() {\n      try {\n        if (!this.apiKey || !this.apiLink) {\n          throw new Error(\"API Key ou API Link manquant\");\n        }\n        \n        // Récupérer toutes les commandes\n        await this.fetchOrders();\n        \n        // Calculer les KPIs\n        this.calculateKPIs();\n        \n        // Générer tous les graphiques\n        this.renderAllCharts();\n        \n      } catch (error) {\n        console.error(\"Erreur lors de la récupération des données:\", error);\n      }\n    },\n    async fetchOrders() {\n      try {\n        // Récupérer toutes les commandes\n        const url = `${this.apiLink}/orders`;\n        console.log(\"URL de récupération des commandes:\", url);\n        const response = await fetch(url, {\n          headers: {\n            \"DOLAPIKEY\": this.apiKey,\n          },\n        });\n        \n        if (!response.ok) {\n          throw new Error(`Erreur réseau: ${response.statusText}`);\n        }\n        \n        const rawOrders = await response.json();\n        console.log(\"Commandes récupérées:\", rawOrders);\n        \n        // Pour chaque commande, récupérer les détails et les factures associées\n        this.allOrders = await Promise.all(\n          rawOrders.map(async (order) => {\n            // Récupérer les détails de la commande\n            const orderDetails = await this.fetchOrderDetails(order.id);\n            \n            // Récupérer la facture associée\n            const invoice = await this.fetchInvoiceForOrder(order.id);\n            \n            return {\n              ...orderDetails,\n              invoice,\n              isPaid: invoice ? invoice.paye === \"1\" || invoice.paye === 1 : false,\n            };\n          })\n        );\n        \n        // Traiter les données pour l'affichage\n        await this.processOrdersData();\n        \n      } catch (error) {\n        console.error(\"Erreur lors de la récupération des commandes:\", error);\n      }\n    },\n    async fetchOrderDetails(orderId) {\n      try {\n        const url = `${this.apiLink}/orders/${orderId}`;\n        const response = await fetch(url, {\n          headers: {\n            \"DOLAPIKEY\": this.apiKey,\n          },\n        });\n        \n        if (!response.ok) {\n          throw new Error(`Erreur réseau pour la commande ${orderId}: ${response.statusText}`);\n        }\n        \n        return await response.json();\n      } catch (error) {\n        console.error(`Erreur lors de la récupération des détails de la commande ${orderId}:`, error);\n        return null;\n      }\n    },\n    async fetchInvoiceForOrder(orderId) {\n      try {\n        const url = `${this.apiLink}/orders/${orderId}/invoices`;\n        const response = await fetch(url, {\n          headers: { DOLAPIKEY: this.apiKey },\n        });\n\n        if (!response.ok) {\n          console.warn(`Pas de facture pour la commande ${orderId}`);\n          return null;\n        }\n\n        const invoices = await response.json();\n        return invoices.length > 0 ? invoices[0] : null;\n      } catch (error) {\n        console.error(\"Erreur de récupération de facture pour commande\", orderId, error);\n        return null;\n      }\n    },\n    async fetchProductCategories(productId) {\n      // Si nous avons déjà récupéré les catégories pour ce produit, utiliser le cache\n      if (this.productCategories[productId]) {\n        return this.productCategories[productId];\n      }\n      \n      try {\n        const url = `${this.apiLink}/products/${productId}/categories`;\n        const response = await fetch(url, {\n          headers: { DOLAPIKEY: this.apiKey },\n        });\n\n        if (!response.ok) {\n          console.warn(`Pas de catégories pour le produit ${productId}`);\n          this.productCategories[productId] = \"Non catégorisé\";\n          return \"Non catégorisé\";\n        }\n\n        const categories = await response.json();\n        if (categories && categories.length > 0) {\n          // Prendre la première catégorie comme catégorie principale\n          const categoryName = categories[0].label || \"Catégorie inconnue\";\n          this.productCategories[productId] = categoryName;\n          return categoryName;\n        } else {\n          this.productCategories[productId] = \"Non catégorisé\";\n          return \"Non catégorisé\";\n        }\n      } catch (error) {\n        console.error(`Erreur lors de la récupération des catégories pour le produit ${productId}:`, error);\n        this.productCategories[productId] = \"Erreur de catégorie\";\n        return \"Erreur de catégorie\";\n      }\n    },\n    getStatusText(order) {\n      switch (order.status) {\n        case \"0\":\n          return \"Brouillon\";\n        case \"1\":\n          if (order.billed && (order.billed === true || order.billed === \"1\")) {\n            return \"Validé-Facturé\";\n          } else if (order.invoice) {\n            return \"Validé-Facture créée\";\n          } else {\n            return \"Validé\";\n          }\n        case \"2\":\n          return \"Facturée\";\n        case \"3\":\n          return \"Livrée\";\n        case \"4\":\n          return \"Traitée\";\n        case \"5\":\n          return \"Payée\";\n        case \"-1\":\n          return \"Annulée\";\n        default:\n          return \"Statut inconnu\";\n      }\n    },\n    getStatusClass(status) {\n      switch (status) {\n        case \"0\": return \"draft\";\n        case \"1\": return \"validated\";\n        case \"2\": return \"invoiced\";\n        case \"3\": return \"processing\";\n        case \"4\": return \"processed\";\n        case \"5\": return \"paid\";\n        case \"-1\": return \"cancelled\";\n        default: return \"unknown\";\n      }\n    },\n    async processOrdersData() {\n      this.paidSalesData = [];\n      this.pendingOrdersData = [];\n      \n      // Traiter chaque commande\n      for (const order of this.allOrders) {\n        // Vérifier si la commande a des lignes\n        if (order.lines && Array.isArray(order.lines)) {\n          const orderDate = this.formatDate(order.date_creation);\n          const clientName = order.socname || \"Client inconnu\";\n          const statusText = this.getStatusText(order);\n          const statusClass = this.getStatusClass(order.status);\n          const isPaid = order.isPaid || order.status === \"5\";\n          \n          // Traiter chaque ligne de la commande\n          for (const line of order.lines) {\n            const productName = line.product_label || line.label || \"Produit inconnu\";\n            const productReference = line.product_ref || \"Référence inconnue\";\n            const quantity = parseFloat(line.qty) || 0;\n            const lineTotal = (parseFloat(line.subprice) * quantity).toFixed(2);\n            \n            // Récupérer la catégorie du produit si nous avons un ID de produit\n            let categoryName = \"Catégorie inconnue\";\n            if (line.fk_product) {\n              categoryName = await this.fetchProductCategories(line.fk_product);\n            }\n            \n            const saleData = {\n              date: orderDate,\n              client: clientName,\n              product: productName,\n              reference: productReference,\n              category: categoryName,\n              quantity: quantity,\n              total: lineTotal,\n              status: statusText,\n              statusClass: statusClass,\n              orderId: order.id,\n              rawStatus: order.status\n            };\n            \n            // Ajouter aux données appropriées selon le statut\n            if (isPaid) {\n              this.paidSalesData.push(saleData);\n            } else {\n              this.pendingOrdersData.push(saleData);\n            }\n          }\n        }\n      }\n      \n      console.log(\"Données des ventes payées:\", this.paidSalesData);\n      console.log(\"Données des commandes en attente:\", this.pendingOrdersData);\n    },\n    calculateKPIs() {\n      // Calculer le total des ventes\n      this.totalSales = this.paidSalesData.reduce((total, sale) => {\n        return total + parseFloat(sale.total);\n      }, 0).toFixed(2);\n      \n      // Nombre total de commandes en attente\n      const uniqueOrders = new Set(this.pendingOrdersData.map(item => item.orderId));\n      this.totalPendingOrders = uniqueOrders.size;\n      \n      // Calcul du panier moyen\n      const uniquePaidOrders = new Set(this.paidSalesData.map(item => item.orderId));\n      const paidOrdersCount = uniquePaidOrders.size;\n      this.averageOrderValue = paidOrdersCount > 0 ? \n        (this.totalSales / paidOrdersCount).toFixed(2) : 0;\n      \n      // Taux de conversion (commandes payées / total des commandes)\n      const totalOrders = uniqueOrders.size + paidOrdersCount;\n      this.conversionRate = totalOrders > 0 ? \n        ((paidOrdersCount / totalOrders) * 100).toFixed(1) : 0;\n    },\n    renderAllCharts() {\n      // Détruire les graphiques existants si nécessaire\n      if (this.charts.categorySalesChart) {\n        Object.values(this.charts).forEach(chart => chart.destroy());\n      }\n      \n      this.renderCategorySalesChart();\n      this.renderSalesTrendChart();\n      this.renderOrderStatusChart();\n      this.renderTopProductsChart();\n      this.renderGeoDistributionChart();\n      this.renderCustomerLoyaltyChart();\n    },\n    renderCategorySalesChart() {\n      const aggregatedByCategory = {};\n      this.paidSalesData.forEach(sale => {\n        aggregatedByCategory[sale.category] = (aggregatedByCategory[sale.category] || 0) + parseFloat(sale.total);\n      });\n\n      const categoryLabels = Object.keys(aggregatedByCategory);\n      const categoryData = categoryLabels.map(label => aggregatedByCategory[label]);\n\n      const ctx = document.getElementById('categorySalesChart');\n      if (ctx) {\n        this.charts.categorySalesChart = new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: categoryLabels,\n            datasets: [\n              {\n                data: categoryData,\n                backgroundColor: [\n                  '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'\n                ],\n                borderWidth: 1\n              },\n            ],\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'right',\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          },\n        });\n      }\n    },\n    renderSalesTrendChart() {\n      // Grouper les ventes par date\n      const salesByDate = {};\n      this.paidSalesData.forEach(sale => {\n        salesByDate[sale.date] = (salesByDate[sale.date] || 0) + parseFloat(sale.total);\n      });\n      \n      // Trier les dates\n      const sortedDates = Object.keys(salesByDate).sort((a, b) => {\n        return new Date(a.split('/').reverse().join('-')) - new Date(b.split('/').reverse().join('-'));\n      });\n      \n      const dateLabels = sortedDates;\n      const dateData = sortedDates.map(date => salesByDate[date]);\n\n      const ctx = document.getElementById('salesTrendChart');\n      if (ctx) {\n        this.charts.salesTrendChart = new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: dateLabels,\n            datasets: [\n              {\n                label: 'Ventes (€)',\n                data: dateData,\n                fill: false,\n                borderColor: '#5AAAD8',\n                tension: 0.1\n              },\n            ],\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                display: true,\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              },\n              x: {\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          },\n        });\n      }\n    },\n    renderOrderStatusChart() {\n      // Combiner les données des commandes payées et en attente\n      const allOrders = [...this.paidSalesData, ...this.pendingOrdersData];\n      \n      // Compter par statut\n      const statusCounts = {};\n      allOrders.forEach(order => {\n        statusCounts[order.status] = (statusCounts[order.status] || 0) + 1;\n      });\n      \n      const statusLabels = Object.keys(statusCounts);\n      const statusData = statusLabels.map(label => statusCounts[label]);\n\n      const ctx = document.getElementById('orderStatusChart');\n      if (ctx) {\n        this.charts.orderStatusChart = new Chart(ctx, {\n          type: 'pie',\n          data: {\n            labels: statusLabels,\n            datasets: [\n              {\n                data: statusData,\n                backgroundColor: [\n                  '#28a745', '#ffc107', '#007bff', '#dc3545', '#6c757d'\n                ],\n                borderWidth: 1\n              },\n            ],\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'right',\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          },\n        });\n      }\n    },\n    renderTopProductsChart() {\n      // Agréger les ventes par produit\n      const salesByProduct = {};\n      this.paidSalesData.forEach(sale => {\n        salesByProduct[sale.product] = (salesByProduct[sale.product] || 0) + parseFloat(sale.total);\n      });\n      \n      // Trier et prendre les 5 meilleurs produits\n      const sortedProducts = Object.entries(salesByProduct)\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 5);\n      \n      const productLabels = sortedProducts.map(item => item[0]);\n      const productData = sortedProducts.map(item => item[1]);\n\n      const ctx = document.getElementById('topProductsChart');\n      if (ctx) {\n        this.charts.topProductsChart = new Chart(ctx, {\n          type: 'bar',\n          data: {\n            labels: productLabels,\n            datasets: [\n              {\n                label: 'Ventes (€)',\n                data: productData,\n                backgroundColor: '#5AAAD8',\n                borderRadius: 6,\n              },\n            ],\n          },\n          options: {\n            indexAxis: 'y',\n            responsive: true,\n            plugins: {\n              legend: {\n                display: false\n              }\n            },\n            scales: {\n              x: {\n                beginAtZero: true,\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              },\n              y: {\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          },\n        });\n      }\n    },\n    renderGeoDistributionChart() {\n      // Dans une implémentation complète, vous pourriez analyser les adresses des clients \n      // Pour l'instant, utilisons des données fictives\n      const geoData = {\n        'Paris': 45,\n        'Lyon': 20,\n        'Marseille': 15,\n        'Bordeaux': 10,\n        'Lille': 5,\n        'Autres': 5\n      };\n      \n      const geoLabels = Object.keys(geoData);\n      const geoValues = Object.values(geoData);\n\n      const ctx = document.getElementById('geoDistributionChart');\n      if (ctx) {\n        this.charts.geoDistributionChart = new Chart(ctx, {\n          type: 'pie',\n          data: {\n            labels: geoLabels,\n            datasets: [\n              {\n                data: geoValues,\n                backgroundColor: [\n                  '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'\n                ],\n                borderWidth: 1\n              },\n            ],\n          },\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'right',\n                labels: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          },\n        });\n      }\n    },\n    renderCustomerLoyaltyChart() {\n      // Dans une implémentation complète, vous pourriez compter les commandes par client\n      // Pour l'instant, utilisons des données fictives\n      const loyaltyData = {\n        labels: ['1 achat', '2-3 achats', '4-5 achats', '6+ achats'],\n        datasets: [\n          {\n            label: 'Nombre de clients',\n            data: [65, 40, 25, 15],\n            backgroundColor: '#5AAAD8',\n            borderRadius: 6,\n          }\n        ]\n      };\n\n      const ctx = document.getElementById('customerLoyaltyChart');\n      if (ctx) {\n        this.charts.customerLoyaltyChart = new Chart(ctx, {\n          type: 'bar',\n          data: loyaltyData,\n          options: {\n            responsive: true,\n            plugins: {\n              legend: {\n                display: false\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              },\n              x: {\n                ticks: {\n                  color: '#1e1e1e'\n                }\n              }\n            }\n          },\n        });\n      }\n    }\n  },\n  watch: {\n    dateFilter: function() {\n      console.log(\"Filtre de date changé:\", this.dateFilter);\n      // Les données sont automatiquement filtrées via le computed property filteredPaidSales\n    },\n    statusFilter: function() {\n      console.log(\"Filtre de statut changé:\", this.statusFilter);\n      // Les données sont automatiquement filtrées via le computed property filteredPendingOrders\n    }\n  }\n};\n</script>\n\n<style scoped>\n.section-title {\n  font-size: 56px;\n  font-family: 'DAWBE';\n  color: #F7F7F7;\n  text-align: left;\n  margin-bottom: 0;\n  margin-top: 0;\n  margin-left: 115px;\n}\n\n.dashboard {\n  padding: 40px 20px;\n  font-family: 'PP Formula', sans-serif;\n  color: #f7f7f7;\n  background-color: #0e100e;\n  text-align: left;\n  min-height: 100vh;\n}\n\nh1, h2, h3 {\n  font-family: 'PP Formula', sans-serif;\n  margin-bottom: 1rem;\n}\n\n.dashboard-content {\n  display: flex;\n  flex-direction: column;\n  gap: 40px;\n  margin-left: 115px;\n  margin-right: 115px;\n  padding-top: 30px;\n}\n\n/* KPI Cards */\n.kpi-container {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 20px;\n  margin-bottom: 20px;\n}\n\n.kpi-card {\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 12px;\n  padding: 20px;\n  flex: 1;\n  min-width: 200px;\n  text-align: center;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.kpi-value {\n  font-size: 28px;\n  font-weight: bold;\n  margin-top: 10px;\n  color: #5AAAD8;\n}\n\n/* Chart layouts */\n.charts-row {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 20px;\n  margin-bottom: 20px;\n}\n\n.chart-container {\n  background: white;\n  padding: 20px;\n  border-radius: 12px;\n  flex: 1;\n  min-width: 300px;\n  color: #1e1e1e;\n}\n\n.chart-container h3 {\n  color: #1e1e1e;\n  margin-bottom: 15px;\n  font-size: 18px;\n}\n\n/* Data tables */\n.data-section {\n  margin-bottom: 40px;\n}\n\n.section-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 15px;\n}\n\n.filters select {\n  padding: 8px 12px;\n  border-radius: 6px;\n  background-color: rgba(255, 255, 255, 0.1);\n  color: #f7f7f7;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.sales-details {\n  background: white;\n  padding: 20px;\n  border-radius: 12px;\n  width: 100%;\n  color: #1e1e1e;\n  overflow-x: auto;\n}\n\ntable {\n  width: 100%;\n  border-collapse: collapse;\n  font-size: 0.9em;\n}\n\nth, td {\n  padding: 12px 15px;\n  text-align: left;\n  border-bottom: 1px solid #ddd;\n}\n\nth {\n  background-color: #f7f7f7;\n  font-weight: bold;\n}\n\n/* Status tags */\n.status-tag {\n  padding: 5px 10px;\n  border-radius: 12px;\n  font-size: 0.85em;\n  color: white;\n  font-weight: 500;\n}\n\n.status-tag.paid {\n  background-color: #28a745;\n}\n\n.status-tag.draft {\n  background-color: #6c757d;\n}\n\n.status-tag.validated {\n  background-color: #007bff;\n}\n\n.status-tag.processing {\n  background-color: #ffc107;\n  color: #1e1e1e;\n}\n\n.status-tag.invoiced {\n  background-color: #17a2b8;\n}\n\n.status-tag.processed {\n  background-color: #20c997;\n}\n\n.status-tag.cancelled {\n  background-color: #dc3545;\n}\n\n.status-tag.unknown {\n  background-color: #6c757d;\n}\n\n.action-btn {\n  padding: 5px 10px;\n  border-radius: 4px;\n  background-color: #5AAAD8;\n  color: white;\n  border: none;\n  cursor: pointer;\n  font-size: 0.85em;\n}\n\n.action-btn:hover {\n  background-color: #4990b8;\n}\n\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}